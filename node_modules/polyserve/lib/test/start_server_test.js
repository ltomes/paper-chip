/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const chai = require("chai");
const chaiAsPromised = require("chai-as-promised");
const fs = require("mz/fs");
const path = require("path");
const pem = require("pem");
const sinon = require("sinon");
const http = require("spdy");
const supertest = require("supertest-as-promised");
const tmp = require("tmp");
const start_server_1 = require("../start_server");
const start_server_2 = require("../start_server");
chai.use(chaiAsPromised);
const assert = chai.assert;
const root = path.join(__dirname, '..', '..', 'test');
suite('startServer', () => {
    test('returns an app', () => {
        const app = start_server_1.getApp({});
        assert.isOk(app);
    });
    test('serves root application files', () => __awaiter(this, void 0, void 0, function* () {
        const app = start_server_1.getApp({ root });
        yield supertest(app).get('/test-file.txt').expect(200, 'PASS\n');
    }));
    test('serves root application files if root isn\t set', () => __awaiter(this, void 0, void 0, function* () {
        const cwd = process.cwd();
        try {
            process.chdir(root);
            const app = start_server_1.getApp({});
            yield supertest(app).get('/test-file.txt').expect(200, 'PASS\n');
        }
        finally {
            process.chdir(cwd);
        }
    }));
    test('serves component files', () => __awaiter(this, void 0, void 0, function* () {
        const app = start_server_1.getApp({ root });
        yield supertest(app)
            .get('/bower_components/test-component/test-file.txt')
            .expect(200, 'TEST COMPONENT\n');
    }));
    test('serves index.html, not 404', () => __awaiter(this, void 0, void 0, function* () {
        const app = start_server_1.getApp({ root });
        yield supertest(app).get('/foo').expect(200, 'INDEX\n');
    }));
    ['html', 'js', 'json', 'css', 'png', 'jpg', 'jpeg', 'gif'].forEach((ext) => {
        test(`404s ${ext} files`, () => __awaiter(this, void 0, void 0, function* () {
            const app = start_server_1.getApp({ root });
            yield supertest(app).get('/foo.' + ext).expect(404);
        }));
    });
    suite('h2', () => {
        let _certFile;
        let _keyFile;
        let _nodeVersion;
        let _serverOptions;
        let _stubServer;
        _setupNodeVersion();
        suiteSetup(() => {
            _setupServerOptions();
            _setupStubServer();
        });
        suiteTeardown(() => {
            _teardownStubServer();
        });
        test('rejects unsupported Node version (< 5) only', function () {
            if (_nodeVersion < 5) {
                return assert.isRejected(start_server_2.startServer(_serverOptions));
            }
            else {
                return assert.becomes(_startStubServer(_serverOptions), _stubServer);
            }
        });
        // Only run h2 tests for Node versions that support ALPN
        const suiteDef = (_nodeVersion < 5) ? suite.skip : suite;
        suiteDef('node5+', () => {
            setup(() => {
                _setupServerOptions();
            });
            test('generates new TLS cert/key if unspecified', () => __awaiter(this, void 0, void 0, function* () {
                const createCertSpy = sinon.spy(pem, 'createCertificate');
                // reset paths to key/cert files so that default paths are used
                _serverOptions.keyPath = undefined;
                _serverOptions.certPath = undefined;
                const certFilePath = 'cert.pem';
                const keyFilePath = 'key.pem';
                _deleteFiles([certFilePath, keyFilePath]);
                try {
                    const server = yield _startStubServer(_serverOptions);
                    assert.isOk(server);
                    yield sinon.assert.calledOnce(createCertSpy);
                    yield Promise.all([
                        fs.readFile(certFilePath)
                            .then(buf => _assertValidCert(buf.toString())),
                        fs.readFile(keyFilePath)
                            .then(buf => _assertValidKey(buf.toString()))
                    ]);
                    yield _deleteFiles([certFilePath, keyFilePath]);
                    yield new Promise((resolve) => server.close(resolve));
                }
                finally {
                    createCertSpy.restore();
                }
            }));
            test('generates new TLS cert/key if specified files blank', () => __awaiter(this, void 0, void 0, function* () {
                const createCertSpy = sinon.spy(pem, 'createCertificate');
                try {
                    const server = yield _startStubServer(_serverOptions);
                    assert.isOk(server);
                    yield sinon.assert.calledOnce(createCertSpy);
                    yield Promise.all([
                        // _certFile and _keyFile point to newly created (blank) temp
                        // files
                        fs.readFile(_certFile.name)
                            .then(buf => _assertValidCert(buf.toString())),
                        fs.readFile(_keyFile.name)
                            .then(buf => _assertValidKey(buf.toString()))
                    ]);
                    yield new Promise((resolve) => server.close(resolve));
                }
                finally {
                    createCertSpy.restore();
                }
            }));
            test('reuses TLS cert/key', () => __awaiter(this, void 0, void 0, function* () {
                _serverOptions.keyPath = path.join(root, 'key.pem');
                _serverOptions.certPath = path.join(root, 'cert.pem');
                const createCertSpy = sinon.spy(pem, 'createCertificate');
                try {
                    const server = yield _startStubServer(_serverOptions);
                    assert.isOk(server);
                    yield sinon.assert.notCalled(createCertSpy);
                    yield new Promise((resolve) => server.close(resolve));
                }
                finally {
                    createCertSpy.restore();
                }
            }));
            test('throws error for blank h2-push manifest', () => {
                const dummyFile = tmp.fileSync();
                _serverOptions.pushManifestPath = dummyFile.name;
                assert.throws(() => start_server_1.getApp(_serverOptions));
            });
            test.skip('pushes only files specified in manifest', () => {
                // TODO: Implement
            });
            test.skip('pushes only files specified in link-preload header', () => {
                // TODO: Implement
            });
            test.skip('does not push files specified as nopush in link-preload header', () => {
                // TODO: Implement
            });
            test.skip('rejects nonexistent file in manifest', () => {
                // TODO: Implement
            });
            test.skip('accepts root path in manifest', () => {
                // TODO: Implement
            });
        });
        function _setupServerOptions() {
            _keyFile = tmp.fileSync();
            _certFile = tmp.fileSync();
            _serverOptions = {
                root,
                protocol: 'h2',
                keyPath: _keyFile.name,
                certPath: _certFile.name
            };
        }
        function _setupNodeVersion() {
            const matches = /(\d+)\./.exec(process.version);
            if (matches) {
                _nodeVersion = Number(matches[1]);
            }
        }
        let createServerStub;
        function _setupStubServer() {
            _stubServer =
                sinon.createStubInstance(http['Server']);
            createServerStub = sinon.stub(http, 'createServer').returns(_stubServer);
            _stubServer.close = (cb) => cb.call(_stubServer);
        }
        function _teardownStubServer() {
            createServerStub.restore();
        }
        function _startStubServer(options) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise(resolve => {
                    _stubServer.listen = (() => resolve(_stubServer));
                    start_server_2.startServer(options);
                });
            });
        }
        function _assertValidCert(cert) {
            return new Promise((resolve, reject) => {
                if (!cert) {
                    reject(new Error('invalid cert'));
                }
                else {
                    pem.readCertificateInfo(cert, (err) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                }
            });
        }
        function _assertValidKey(key) {
            return new Promise((resolve, reject) => {
                if (/BEGIN[^]+?KEY[^]+END[^]+?KEY/.test(key)) {
                    resolve();
                }
                else {
                    reject(new Error('invalid key'));
                }
            });
        }
        function _deleteFiles(files) {
            for (const file of files) {
                try {
                    fs.unlinkSync(file);
                }
                catch (e) {
                }
            }
        }
    });
});
suite('startServers', () => {
    suite('variants', () => {
        const variantsRoot = path.join(root, 'variants');
        let prevCwd;
        setup(() => {
            prevCwd = process.cwd();
            process.chdir(variantsRoot);
        });
        teardown(() => {
            process.chdir(prevCwd);
        });
        test('serves files out of a given components directory', () => __awaiter(this, void 0, void 0, function* () {
            const servers = yield start_server_2.startServers({});
            if (servers.kind !== 'MultipleServers') {
                throw new Error('Expected startServers to start multiple servers');
            }
            const mainlineServer = servers.mainline;
            yield supertest(mainlineServer.server)
                .get('/components/contents.txt')
                .expect(200, 'mainline\n');
            const fooServer = servers.variants.find(s => s.variantName === 'foo');
            yield supertest(fooServer.server)
                .get('/components/contents.txt')
                .expect(200, 'foo\n');
            const barServer = servers.variants.find(s => s.variantName === 'bar');
            yield supertest(barServer.server)
                .get('/components/contents.txt')
                .expect(200, 'bar\n');
            const dispatchServer = servers.control;
            const dispatchTester = supertest(dispatchServer.server);
            const apiResponse = yield dispatchTester.get('/api/serverInfo').expect(200);
            assert.deepEqual(JSON.parse(apiResponse.text), {
                packageName: 'variants-test',
                mainlineServer: { port: mainlineServer.server.address().port },
                variants: [
                    { name: 'bar', port: barServer.server.address().port },
                    { name: 'foo', port: fooServer.server.address().port }
                ]
            });
            const pageResponse = yield dispatchTester.get('/').expect(200);
            // Assert that some polyserve html is served.
            assert.match(pageResponse.text, /<html>/);
            assert.match(pageResponse.text, /Polyserve/);
        }));
    });
});
//# sourceMappingURL=start_server_test.js.map